# 序
无论有多少测试,如果你不能信任、维护以及阅读它们，这些测试就几乎没有价值。优秀的测试，应该同时具有如下三个属性。

+ 可靠性
+ 可维护性
+ 可读性

## 1. 编写可靠的测试
+ 决定何时删除或修改测试
+ 避免测试中的逻辑
+ 只测试一个关注点
+ 把单元测试和集成测试分开
+ 推动代码审查

### 1.1 决定何时删除或修改测试
删除一个测试的主要理由是这个测试失败了。如果一个测试突然开始失败，可能有如下原因：
+ 产品缺陷
+ 测试缺陷
+ 语义或者API变更
+ 冲突或者无效测试

如果测试或代码没有任何问题，修改或删除测试的原因有：
+ 重命名或者重构测试
+ 去除重复代码

#### 1.1.1 产品缺陷
进行单元测试的最佳结果

#### 1.1.2 测试缺陷
+ 修复测试中的缺陷
+ 确保测试该失败时会失败
+ 确保测试该通过时会通过

#### 1.1.3 语义或者API变更
+ 语义变更：被测对象的使用方式发生了变化
AutoFixture:可以用作一个智能对象工厂，帮助你创建被测试对象，免除对构造函数结构的担忧。

#### 1.1.4 冲突或者无效的测试
如果产品代码引入一个新功能，和一个测试有直接冲突，就产生了一个冲突问题。这种情况下，测试没有发现缺陷，却发现了冲突的产品需求。

#### 1.1.5 重命名或者重构测试
不可读测试带来的麻烦比解决的问题更多。它会影响代码的可读性，妨碍你理解测试发现的问题。

#### 1.1.6 删除重复测试


### 1.2 避免测试中的逻辑
包含逻辑就容易有缺陷.

### 1.3 只测试一个关注点

### 1.4 将单元测试与集成测试分开

### 1.5 用代码审查保障覆盖率

## 2. 编写可维护的测试
+ 只测公共契约
+ 删除重复测试
+ 实施测试隔离

### 2.1 测试私有或保护方法
### 2.2 去除重复代码
### 2.3 以可维护的方法使用setup
### 2.4 实施测试隔离
+ 强制的测试顺序
+ 隐藏的测试调用
+ 共享状态损坏
+ 外部共享状态损坏

### 2.5 避免对不同关注点多次断言
使用参数化测试

### 2.6 对象比较
### 2.7 避免过度指定
+ 指定纯内部行为
+ 在需要使用存根时使用内部对象
+ 不必要的顺序指定或精确匹配


## 3.编写可读的测试

### 3.1 单元测试命名
+ 被测试方法名
+ 测试场景
+ 预期行为

### 3.2 变量命名

### 3.3 有意义的断言
+ 不要重复测试框架的控制台输出信息
+ 不要重复测试名中包含的信息
+ 如果没什么有用的信息，就什么也不要说
+ 提供关于什么应该发生和什么没有发生的信息，如果可能的话，提供应该发生的时间

### 3.4 断言和操作分离

### 3.5 setup和teardown


# 总结
测试要随着被测系统一同成长和变化
如果人们能读懂你的测试，就能够理解和维护测试，如果测试能够通过，他们也会信任测试。


